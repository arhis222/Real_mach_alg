-- top.lus
-- dépendances : PC.lus, PO.lus (votre 5.lus renommé), multv6base2.lus, UALCryptoV6.lus
include "PC.lus"
include "../PO/5.lus"


node top_debug <<const n:int>>(
  begin   : bool;    -- checkbox "begin"
  chM     : bool;    -- checkbox "chM"
  chEXP   : bool;    -- checkbox "chEXP"
  chN     : bool;    -- checkbox "chN"
  input   : int      -- slider "input" (valeur entière à charger)
)
returns (
  m       : int;  -- affichage registre M
  exp     : int;  -- affichage registre EXP
  nreg    : int;  -- affichage registre N
  end_    : bool;    -- flag "end_"
  q       : int;   -- copie de "code" si vous voulez un label supplémentaire
  -- Signaux de débogage
  etat_courant : bool^11;

  Sig_chExp : bool;
  Sig_chCode : bool;
  Sig_chN: bool;
  Sig_chM : bool;

   mise_1 : bool;

  selOp1 : bool^2;    -- commande UAL (issue de PC)
  selOp2 : bool;
  opUAL : bool^2;    -- commande UAL (issue de PC)

  Sig_C : bool;      -- flag Carry
  Sig_Z : bool;      -- flag Zero
  Sig_Odd : bool;    -- flag Odd

    
);
var
  Z, C, Odd       : bool;      -- flags retour UAL
  --selOp1          : bool^2;    -- commande UAL (issue de PC)
  --selOp2          : bool;      
  --opUAL           : bool^2;    
  -- vecteur de bits issu du slider
  busIn           : bool^n;    
  -- bus interne de sortie PO
  code_bits       : bool^n;

  reset : bool;      -- reset PO



  code : int;  -- code de sortie
  --signale de mise à 1
 
  Sig_chM_interne : bool;
  Sig_chExp_interne : bool;
  Sig_chN_interne : bool;
  Sig_chCode_interne : bool;

  -- vecteurs de bits issus des registres
  selExt : bool;  -- 1 = charger depuis busIn (initialisation), 0 = recirculer UAL
let
  ----------------------------------------------------------------
  -- conversion de l'entier 'input' en bus de n bits (LSB à l'indice 0)
  busIn = natier16(input);

  ----------------------------------------------------------------
  -- Partie opérative (PO) : on charge manuellement via 'begin',chM,chEXP,chN
  ( code_bits, Z, C, Odd ,code, m, nreg, exp ) =
    PO<<n>>(false,
            reset,      -- reset PO = false (on ne reset pas ici)
            not begin,      -- selExt = !begin
            busIn,      -- bus d'entrée
            Sig_chCode_interne,      -- chCode = begin (on force reset à 1 pour initialiser CODE=1)
            Sig_chM_interne,        -- chM     = checkbox chM
            Sig_chExp_interne,      -- chExp   = checkbox chEXP
            Sig_chN_interne,        -- chN     = checkbox chN
            selOp1,     -- commande alu issue de PC
            selOp2,
            opUAL,
            mise_1      
    );

    Sig_chExp_interne = mux1(begin, Sig_chExp, chEXP);
    Sig_chN_interne = mux1(begin, Sig_chN, chN);
    Sig_chM_interne = mux1(begin, Sig_chM, chM);
    Sig_chCode_interne = mux1(begin, Sig_chCode, false);

    reset = (not pre begin) and begin;
 

  ----------------------------------------------------------------
  -- Partie contrôle (PC) : on reset PC quand begin=0→1, on récupère
  -- uniquement les commandes sorties; on ignore ici selExt/chCode/ch*
  ( Sig_chExp, Sig_chCode, Sig_chN, Sig_chM,
    selExt, selOp1, selOp2,
    opUAL, end_, mise_1,etat_courant ) =
    PC(false,
       not begin,  -- RESET_PC = 1 quand begin passe à 0→1 (synchronous)
       Z, C, Odd);

  ----------------------------------------------------------------
  -- sorties finales
  q    = entiernat<<n>>(code_bits);  -- alias si besoin  
  Sig_C = C;
  Sig_Z = Z;
  Sig_Odd = Odd;

tel;

------
--utilisation top_debug
-- inst_top16.lus

-- On fixe n = 16
node top16(
  begin   : bool;
  chM     : bool;
  chEXP   : bool;
  chN     : bool;
  input   : int
)
returns (
  m      : int;
  exp    : int;
  n      : int;
  end_    : bool;
  q      : int;
  -- Signaux de débogage
  etat_courant : bool^11;
  Sig_chExp : bool;
  Sig_chCode : bool;
  Sig_chN: bool;
  Sig_chM : bool;
   mise_1 : bool;
  selOp1 : bool^2;    -- commande UAL (issue de PC)
  selOp2 : bool;
  opUAL : bool^2;    -- commande UAL (issue de PC)
  Sig_C : bool;      -- flag Carry
  Sig_Z : bool;      -- flag Zero
  Sig_Odd : bool;    -- flag Odd
);
let
  -- On déplie top_debug avec n=8
   (m, exp, n, end_, q, etat_courant,Sig_chExp,Sig_chCode,Sig_chN,Sig_chM, mise_1, selOp1, selOp2, opUAL, Sig_C, Sig_Z, Sig_Odd) =
    top_debug<<16>>(begin, chM, chEXP, chN, input);
tel;



-- natier :

-- natier8.lus
-- Convertit un entier i en vecteur de 8 bits (LSB en position 0)
function natier8(i:int) returns (b: bool^8);
let
  b[0] = (i mod 2) = 1;
  b[1] = ((i / 2)   mod 2) = 1;
  b[2] = ((i / 4)   mod 2) = 1;
  b[3] = ((i / 8)   mod 2) = 1;
  b[4] = ((i / 16)  mod 2) = 1;
  b[5] = ((i / 32)  mod 2) = 1;
  b[6] = ((i / 64)  mod 2) = 1;
  b[7] = ((i / 128) mod 2) = 1;
tel;

-- Convertit un entier i en vecteur de 16 bits (LSB en position 0)
function natier16(i:int) returns (b: bool^16);
let
  b[0]  = (i mod 2) = 1;
  b[1]  = ((i / 2)   mod 2) = 1;
  b[2]  = ((i / 4)   mod 2) = 1;
  b[3]  = ((i / 8)   mod 2) = 1;
  b[4]  = ((i / 16)  mod 2) = 1;
  b[5]  = ((i / 32)  mod 2) = 1;
  b[6]  = ((i / 64)  mod 2) = 1;
  b[7]  = ((i / 128) mod 2) = 1;

  b[8]  = ((i / 256) mod 2) = 1;
  b[9]  = ((i / 512) mod 2) = 1;
  b[10] = ((i / 1024) mod 2) = 1;
  b[11] = ((i / 2048) mod 2) = 1;
  b[12] = ((i / 4096) mod 2) = 1;
  b[13] = ((i / 8192) mod 2) = 1;
  b[14] = ((i / 16384) mod 2) = 1;
  b[15] = ((i / 32768) mod 2) = 1;

tel;


